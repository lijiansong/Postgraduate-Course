# Term
### 函数式编程：[《前端函数式攻城指南》](https://github.com/jcouyang/clojure-flavored-javascript/tree/source)
- 编程范式：命令式、面向对象、函数式、逻辑式
- 函数式：高阶函数、不可变性、惰性求值
- JavaScript中的函数式支持：函数作为参数、函数作为返回值、箭头函数、尾递归优化、Destructure
- 模式匹配：Scala、Haskell的核心所在
- 惰性求值：求值的过程并不会立刻发生
- 面向对象可以通过继承和组合在对象之间分享一些行为或者属性，函数式的思路就是通过组合已有的函数形成一个新的函数
- 把尾递归换成循环很容易，关键是需要让解释器识别尾递归
- 集合：向量(vector)是不可变immutable、持久性的数据结构，不可变的意思是不需要深入判等，只需要简单地比较实例引用的是否还是原来的那块内存就行了；持久性的意思是每当尝试去修改一个不可变的数据结构的时候，其实会返回一个建立在旧数据的基础上的新数据结构
- 集合：map的所有操作都不会改变原来的不可变对象
- 函数组合子：map把参数中的函数应用到集合中每一个元素上，并返回函数返回的元素组成的新集合；filter接收一个谓词函数(predicate function)，用于判断哪些元素应该保留，哪些元素应该被剔除；reduce将集合规约成值；take常用于从一个集合中取出一部分；takeWhile动态地计算是否需要将元素取出来，第一个参数是谓词；类似地，drop和dropWhile
- 向量的`持久性和不可变性，同时保证效率`：持久性是指数据结构在被操作的时候永远保持着前一版本；不可变性是说不管是什么，在被创建之后就再也不能被改变。所以，持久性约束的是操作，而不可变性约束的是数据
- Clojure的向量数据结构并不是简单的链表，而是Rich Hickey发明的树形数据结构，每一个节点有32叉的树形结构，具体可以自己查阅vector底层的源码
- 函数式编程“引用透明性”：函数对于相同输入一定返回相同的输出，因此将其替换成它的输出，也不会影响程序的结果，斐波那契函数就是一个典型的例子
- Facebook的UI库ReactJS相对容易推理，因为它使用了单向数据流状态机模型
- 惰性求值的实现
- 不动点(fixed-point) f(x)=x
- 通信顺序进程CSP是一种用于描述并发系统中交互的形式语言，来源于C.A.R Hoare(快排的作者)1978年的论文。CSP由于Go语言的兴起突然复活，Go给自己的CSP实现起名叫"goroutines and channels"，取自coroutine协程。CSP的概念很简单，想象一下时间循环，CSP把这个时间循环的消息队列转换成一个数据队列，叫做Channel的数据队列；然后任务等待队列中的数据。这样做的好处就是成功地把任务和异步数据从回调中分离开来。多个人物可以并发进行，所有的任务之间没有相互依赖，之间完全没有callback。每个任务中的go-loop循环获取channel中的数据，当队列为空时，状态变为parking，并没有阻塞线程，而是保存当前的状态，继续去试另一个Go语句
